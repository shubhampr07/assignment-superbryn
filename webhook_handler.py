"""
LiveKit Webhook Handler

This module handles webhook events from LiveKit to log and track voice agent calls.
LiveKit sends webhooks for various events like room creation, participant joining, etc.

The webhook payload construction happens within the LiveKit server environment and is
sent to this handler endpoint.
"""

from flask import Flask, request, jsonify
import hmac
import hashlib
import json
import logging
from datetime import datetime
from typing import Dict, Any
import os
from dotenv import load_dotenv

load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)

# Store call logs (in production, use a database)
call_logs = []

# Webhook secret for verification
WEBHOOK_SECRET = os.getenv("WEBHOOK_SECRET", "")


def verify_webhook_signature(payload: bytes, signature: str) -> bool:
    """
    Verify the webhook signature to ensure it's from LiveKit.
    
    Args:
        payload: Raw request body
        signature: Signature from X-LiveKit-Signature header
    
    Returns:
        bool: True if signature is valid
    """
    if not WEBHOOK_SECRET:
        logger.warning("WEBHOOK_SECRET not set, skipping signature verification")
        return True
    
    expected_signature = hmac.new(
        WEBHOOK_SECRET.encode(),
        payload,
        hashlib.sha256
    ).hexdigest()
    
    return hmac.compare_digest(expected_signature, signature)


def extract_webhook_fields(webhook_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Extract and document the webhook payload fields.
    
    Webhook Payload Structure (constructed by LiveKit server):
    
    1. event: String identifier for the type of event
       - Constructed from: LiveKit event system based on server-side state changes
       - Examples: "room_started", "room_finished", "participant_joined", "participant_left"
    
    2. room: Object containing room metadata
       - sid: Room Session ID (unique identifier for the room session)
       - name: Room name (specified when creating the room)
       - emptyTimeout: Time before empty room is closed
       - maxParticipants: Maximum allowed participants
       - creationTime: Unix timestamp when room was created
       - metadata: Custom metadata string attached to the room
       - numParticipants: Current number of participants
       - numPublishers: Number of participants publishing tracks
       - activeRecording: Boolean indicating if recording is active
    
    3. participant: Object containing participant information (if applicable)
       - sid: Participant Session ID
       - identity: Unique participant identifier (user-provided or generated)
       - name: Display name of the participant
       - metadata: Custom metadata string attached to the participant
       - joinedAt: Unix timestamp when participant joined
       - state: Current state (ACTIVE, DISCONNECTED, etc.)
       - tracks: Array of track information (audio/video)
    
    4. track: Object containing track information (for track events)
       - sid: Track Session ID
       - type: Track type (AUDIO, VIDEO, DATA)
       - name: Track name/label
       - muted: Boolean indicating if track is muted
       - source: Track source (CAMERA, MICROPHONE, SCREEN_SHARE, etc.)
    
    5. createdAt: Unix timestamp when the webhook event was created
       - Constructed from: LiveKit server's system time when event occurred
    
    6. id: Unique identifier for this webhook event
       - Constructed from: UUID generated by LiveKit server for this specific webhook delivery
    
    All these fields are constructed within the LiveKit server environment based on:
    - Room state management system
    - Participant connection tracking
    - Media track publishing/unpublishing events
    - Server-side timing and session management
    """
    
    return {
        "event_type": webhook_data.get("event"),
        "event_id": webhook_data.get("id"),
        "created_at": webhook_data.get("createdAt"),
        "room_info": {
            "sid": webhook_data.get("room", {}).get("sid"),
            "name": webhook_data.get("room", {}).get("name"),
            "num_participants": webhook_data.get("room", {}).get("numParticipants"),
            "creation_time": webhook_data.get("room", {}).get("creationTime"),
        },
        "participant_info": {
            "sid": webhook_data.get("participant", {}).get("sid"),
            "identity": webhook_data.get("participant", {}).get("identity"),
            "joined_at": webhook_data.get("participant", {}).get("joinedAt"),
        } if webhook_data.get("participant") else None,
    }


@app.route("/webhook", methods=["POST"])
def handle_webhook():
    """
    Handle incoming webhooks from LiveKit.
    
    LiveKit sends POST requests to this endpoint with event data.
    """
    try:
        # Get raw payload for signature verification
        raw_payload = request.get_data()
        signature = request.headers.get("X-LiveKit-Signature", "")
        
        # Verify signature
        if not verify_webhook_signature(raw_payload, signature):
            logger.error("Invalid webhook signature")
            return jsonify({"error": "Invalid signature"}), 401
        
        # Parse webhook data
        webhook_data = request.json
        
        if not webhook_data:
            return jsonify({"error": "No data provided"}), 400
        
        # Extract fields
        extracted_data = extract_webhook_fields(webhook_data)
        
        # Log the event
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "raw_webhook": webhook_data,
            "extracted_fields": extracted_data,
        }
        
        call_logs.append(log_entry)
        
        # Log to console
        logger.info(f"Webhook received: {extracted_data['event_type']}")
        logger.info(f"Room: {extracted_data['room_info']['name']}")
        if extracted_data['participant_info']:
            logger.info(f"Participant: {extracted_data['participant_info']['identity']}")
        
        # Pretty print the webhook data
        print("\n" + "="*80)
        print("WEBHOOK EVENT RECEIVED")
        print("="*80)
        print(json.dumps(extracted_data, indent=2))
        print("="*80 + "\n")
        
        return jsonify({"status": "success", "event_processed": extracted_data['event_type']}), 200
        
    except Exception as e:
        logger.error(f"Error processing webhook: {str(e)}")
        return jsonify({"error": str(e)}), 500


@app.route("/logs", methods=["GET"])
def get_logs():
    """
    Retrieve all call logs.
    """
    return jsonify({
        "total_events": len(call_logs),
        "logs": call_logs
    })


@app.route("/health", methods=["GET"])
def health_check():
    """
    Health check endpoint.
    """
    return jsonify({"status": "healthy", "service": "webhook_handler"})


if __name__ == "__main__":
    port = int(os.getenv("WEBHOOK_PORT", 8080))
    logger.info(f"Starting webhook handler on port {port}")
    app.run(host="0.0.0.0", port=port, debug=True)
